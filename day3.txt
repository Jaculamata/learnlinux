2015-12-24
第一章程序结构和执行
文本文件：只由ASCII字符组成的文件
区分不同对象的方法是数据对象的上下文
hello程序生命周期：
.c（文本）源程序
预处理器（cpp）读取系统头文件，并直接插入到程序文本中
.i（文本）被修改的源程序
编译器ccl  产生汇编语言
.s（文本）汇编程序
汇编器 as 将代码翻译成机器语言指令
.o（二进制）
链接器ld  负责将单独预编译好的例如printf函数合并到.o文件中 
可执行目标程序（二进制）
hello运行示例程序过程
键盘输入字符串---外壳程序--->I/O总线--->I/O桥--->系统总线---总线接口--->寄存器
敲击回车键时---外壳执行一系列操作加载hello文件  将目标文件的代码和数据从磁盘复制到主存
即磁盘---磁盘控制器----I/O总线---I/O桥---存储器总线---主存储器
加载到主存后，执行机器语言指令，将输出字节从主存复制到寄存器文件，再从寄存器复制到显示设备
即主存---存储器总线---I/O桥---系统总线---总线接口---寄存器
                        |                               | 
						|-------------原路返回----------|
                    图形适配器
					    |
					显示器
高速缓存处理器：较大的存储设备运行速度较小的慢。
作为暂时的集结区域，用来存放处理器近期可能会有需要的信息
让高速缓存里存放可能经常访问的数据，大部分存储器操作都能在快速的高速缓存中完成
处理器和设备之间插入一个更小更快的存储设备  即存储设备形成层次结构
L0寄存器---L1高速缓存SRAM---L2高速缓存SRAM---L3高速缓存SRAM---L4主存DRAM---L5本地二级存储（本地磁盘）---L6远程二级存储（分布式文件系统，Web服务器）
向上更小更快，每字节更贵，向下则相反
一层上的存储器作为低一层存储器的高速缓存
操作系统是应用程序和硬件之间的插入的一层软件
操作系统功能：防止硬件被失控的应用程序滥用 ；向应用程序提供大相径庭的低级硬件设备
通过抽象概念实现：进程，虚拟存储器，文件
文件：对I/O设备的抽象表示
虚拟存储器：对主存和磁盘I/O设备的抽象表示
进程：处理器，主存，I/O设备的抽象表示
 
进程  交错执行机制：上下文切换
      操作系统保持跟踪进程运行所需的所有状态信息
      当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前当前进程的上下文，恢复新进程的上下文
      一个进程可由多个线程组成 
      线程运行在进程的上下文中，共享同样的代码和全局数据
虚拟存储器
      虚拟地址空间：  地址由下往上增大
      内核虚拟存储器： 驻留在内存中，视为操作系统的一部分
	  用户栈      编译器用他来实现函数调用，可以动态扩展
	  共享库      标准库和数据库
	  堆          运行时堆  运行时动态扩展和收缩
	  程序代码和数据：
文件  字节序列
网络可视为一个I/O设备

并发：一个同事具有多个活动的系统
并行：用并发是一个系统运行的更快
线程级并发
指令级并行
单指令，多数据并行

计算机系统中抽象的重要性
提供不同层次的抽象表示，来隐藏实际实现的复杂性
文件是对I/O的抽象，虚拟存储器是对程序存储器的抽象，进程是对一个正在运行的程序的抽象，虚拟机对照整个计算机的抽象

第二章信息的表示和处理
2.1信息存储
C语言的一个指针的值都是某个存储块的第一个字节的虚拟地址	  
2.1.1十六进制  Ox或者 ox
2.1.2字
每台计算机都有一个字长，指明整数和指针数据的标称大小  32 64 位
2.1.3数据大小
32位4字节   64位8字节    指针使用机器的全字长
2.1.4寻址和字节顺序
几乎所有机器上，多字节对象存储为连续的字节序列
大端法：最高有效字节在前
小端法：最低有效字节在前
只要选择了一种规则并且始终如一的坚持，其实对于哪种字节排序的选择都是任意的
2.1.5表示字符串
C语言中字符串被编码为一个以null字符结尾的字符数组
在使用ASCII码作为字符码的任何系统上都将得到相同的结果，与字节顺序和字大小规则无关
文本数据比二进制数据具有更强的平台独立性
Unicode：ASCII字符集适合于英文文档，Unicode统一字符集包括多种语言且姜蓉ASCII
2.1.6表示代码
不同机器类型使用不同的且不兼容的指令和编码方式
即使完全一样的进程在不同的操作系统上也会有不同的编码规则
二进制代码因此不兼容
2.1.7布尔代数
布尔运算
&与  |或   ~非 ^异或
2.1.8C语言中的位级运算
支持按位布尔运算  任何整型数据类型 char 或int
练习2.10 a^a=0;0^a=a
不使用中间容器交换 两数x,y
x=x^y;y=y^x;x=x^y;
掩码运算：掩码是一个位模式，表示从一个字中选出的位的集合
2.1.9 C语言中的逻辑运算
&&与  ||或  ！非
2.1.10 移位运算
>>右移---|逻辑右移空位补0
         |算数右移空位补1
<<左移末位补0
思考位移运算使用二进制
2.2整数表示
2.2.1整数数据类型
负数的范围比整数的范围大1
C语言的整型数据典型取值范围
char 2^8 一字节
int 2^32  4字节
C语言的整型数据的保证的取值范围
char 2^8  一字节
int 2^16 2字节
2.2.2无符号数的编码
binary to unsigned函数
无符号数二进制表示的重要属性：每个介于0-(2^w)-1之间的数都有唯一一个w位的值编码
2.2.3补码编码
有符号数的计算机表示方法：补码two's-complement
将字的最高有效位解释为负权 ，符号位 权重为-2^(w-1)

C语言标准只指定了每种数据类型的最小范围
有符号数的其他表示方法
反码 ：最高有效位的权是-（2^(w-1)-1）
原码 ：最高有效位是符号位
但是这两种机器对于0有两种不同的编码方式 ±0
2.2.4有符号数和无符号数之间的转换
强制类型转换的结果保持位值不变，只是改变解释这些位的方式
无符号与补码的关系：x为正时，相等
为负时 两者之差的绝对值等于2^w
从补码的定义中可以看出
为什么要采用补码呢
2.2.5C语言中的有符号数和无符号数
默认有符号的，要创建一个无符号常量，必须加上后缀字符”U“或”u“
转换原则 底层的位表示保持不变
而在一台采用补码的机器上，无符号转换为有符号数，效果就是应用U2T
有符号到无符号是T2U
printf输出数值时 %d %u %x分别表示有符号十进制，无符号十进制和十六进制
当执行一个运算时，如果他的一个运算数是有符号而另外一个是无符号的，那么C语言会隐式地将有符号数强制类型转换为无符号数
2.2.6 扩展一个数字的位表示
无符号数：开头添0
补码数字：符号扩展 在表示中添加最高有效位的副本
P77
